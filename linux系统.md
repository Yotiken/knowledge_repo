
### 链接

- 静态链接的主要任务

  - 符号解析

    目标文件定义和引用符号,每个符号对应于一个函数、一个全局变量或一个静态变量(即C语言中任何以 static 属性声明的变量)。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。

    - 编译器生成符号表，给每一个符号唯一的名字。当编译器遇到一个外部模块定义的符号（变量or函数名），会交给链接器处理。
  - 重定位
- 符号和符号表

  定义为带有C static 属性的本地过程变量是不在stack中管理的。编译器在.data or .bss中为每个定义分配空间，并在符号表中创建一个有唯一名字的链接器符号。

  - 由模块m定义并能够被其他模块引用的全局符号。

    - 非静态的c函数、全局变量
  - 由其他模块定义并被模块m引用的全局符号。

    - 其他模块中定义的非静态c函数、全局变量
  - 只被m定义和引用的局部符号。

    - static的c函数、全局变量。这些符号在m中任何位置可见，但是不能被其他模块引用。
- 链接器如何解析多重定义的全局符号

  - 在编译时,编译器向汇编器输出每个全局符号,或者是强(strong)或者是弱(weak), 而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号,未初始化的全局变量是弱符号。根据强弱符号的定义,Linux 链接器使用下面的规则来处理多重定义的符号名: •

    - 规则1:不允许有多个同名的强符号。
    - • 规则2:如果有一个强符号和多个弱符号同名,那么选择强符号。
    - • 规则3:如果有多个弱符号同名,那么从这些弱符号中任意选择一个。
- 静态库如何链接

  - 在linux中，静态库以archive的文件格式存放在磁盘中。archive文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。
- 程序是怎么找到动态链接的？

  动态库的加载是延迟进行的，即在首次需要时才加载，而不是在程序启动时就加载所有动态库。加载动态库的过程一般包括以下步骤：`<br>`1 符号解析： 当程序执行到调用动态库中的函数时，会进行符号解析，即查找该函数的符号（函数名或其他标识符）。如果在当前可执行文件的符号表中找不到对应的符号，说明该函数可能在动态库中。`<br>`2 动态库加载： 在进行符号解析后，操作系统会尝试从预先设定的动态链接库搜索路径中加载相应的动态库。搜索路径通常包括系统默认的库路径和用户指定的库路径。`<br>`3 动态库中的符号查找： 一旦找到了可能包含该函数的动态库，操作系统会在动态库的符号表中继续查找对应的符号。如果在动态库的符号表中找到了对应的符号，说明该函数确实是在动态库中定义的。`<br>`4 动态库加载到内存： 最终，如果动态库中的函数和符号解析匹配成功，操作系统将把动态库加载到程序的内存空间中，并完成符号绑定，使得程序可以正确地调用动态库中的函数。`<br>`需要注意的是，一旦动态库被加载到内存中，它将保持在内存中供程序使用，直到程序结束或动态库被显式地卸载。动态库的加载和卸载是由操作系统动态管理的，而不是在编译链接阶段确定的。这使得程序可以根据需要加载和卸载动态库，从而实现更加灵活的模块化和共享代码的机制。`<br>`
- 执行的时候，遇到一个函数，如何判断这个函数是不是在动态库中？

  1 符号查找： 当程序执行到一个函数调用时，它会根据函数名在当前可执行文件的符号表中查找对应的符号（函数名或其他标识符）。如果在当前可执行文件的符号表中找到了对应的符号，说明该函数是在当前可执行文件中定义的，不属于动态库。`<br>`2 动态库加载： 如果在当前可执行文件的符号表中没有找到对应的符号，说明该函数可能在动态库中。这时，操作系统会尝试从预先设定的动态链接库搜索路径中加载相应的动态库。`<br>`3 动态库中的符号查找： 一旦找到了可能包含该函数的动态库，操作系统会在动态库的符号表中继续查找对应的符号。如果在动态库的符号表中找到了对应的符号，说明该函数确实是在动态库中定义的。`<br>`

### 内存

- 内存分区

  - 栈
  - 堆[[C++#^1c29f3]] ^9ab37e

    - 由malloc分配的内存块
  - 内核空间
  - 代码段

    - .text

      - 存储的是程序源代码编译后的机器指令。只读。
  - 全局、静态段

    - .rodata(read only data)

      - 只读数据段，存放的是程序中的只读数据，如只读变量、字符串常量。
    - .bss

      - 存放未初始化的全局静态变量和局部静态变量。
- 不同段上对象的生命周期

  - 数据段.bss

    - 与程序的生命周期相同。代码段在程序加载到内存时被分配，在程序结束时被释放。
  - 堆
  - 栈
- 堆和栈的区别

  - 分配和管理的方式不同：

    - 堆是动态分配的，分配和释放都由程序员控制
    - 栈时编译器自动管理的，释放都由编译器完成
  - 产生碎片不同：

    - 对堆来说，频繁使用new/delete或者malloc/free会造成内存空间的不连续，产生大量碎片
    - 对栈来说，不存在碎片问题，因为栈具有先进后出的特点
  - 生长方向不同:

    - 堆是向内存地址增加的方向增长的，从内存的低地址向高地址方向增长
    - 栈是向内存地址减小的方向增长的，从内存的高地址向低地址方向增长
  - 申请大小限制不同：

    - 栈顶和栈底都是预设好的，大小固定
    - 堆是不连续的内存控件，其大小可以灵活调整
  - 生命周期不同
- 静态内存分配和动态内存分配有什么区别

  - 静态内存分配是在编译时期完成的，不占用CPU资源；动态内存分配是在运行时期完成的，分配和释放需要占用CPU资源
  - 静态内存分配是在栈上分配的，动态内存分配是在堆上分配的
  - 静态内存分配不需要指针或引用类型的支持，动态内存分配需要
  - 静态内存分配是按计划分配的，在编译前确定内存块大小，动态内存分配是按需要分配的
  - 静态内存分配是把内存的控制权交给了编译器，动态内存分配是把内存的控制权交给了程序员
  - 静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏
- 64位虚拟地址空间是2^64,但是物理地址没这么大，所以为什么会这样？

  现代计算机使用内存管理单元（Memory Management Unit，MMU）来实现虚拟地址到物理地址的映射。通过使用页面表（Page Table），MMU能够将虚拟地址映射到物理地址。操作系统会根据需要来进行虚拟地址到物理地址的动态映射，将当前活跃的内存页加载到物理内存中，而不是一次性将整个虚拟地址空间映射到物理地址空间中。`<br>`

### 通信

- 进程、线程、携程

  - 线程优先级

    1-10；创建时设置优先级。运行时不能修改优先级。`<br>`
  - 进程

    进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是`<b>`系统进行资源分配和调度的基本单位`</b>`，是操作系统 http://baike.baidu.com/view/880.htm
    结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。`<br>`进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码 http://baike.baidu.com/view/41.htm
    ，还包括当前的活动，通过程序计数器 http://baike.baidu.com/view/178145.htm
    的值和处理寄存器 http://baike.baidu.com/view/6159.htm
    的内容来表示。`<br>`进程的概念主要有两点：第一，进程是一个实体。`<b>`每一个进程都有它自己的地址空间`</b>`，一般情况下，包括文本 http://baike.baidu.com/view/300107.htm
    区域（text region）、数据区域（data region）和堆栈 http://baike.baidu.com/view/93201.htm
    （stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理 http://baike.baidu.com/view/989420.htm
    器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程 http://baike.baidu.com/view/19746.htm
    。`<br>`进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。`<b>`由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。`</b><br>`
  - 线程

    `<b>`线程是进程的一个实体,是CPU调度和分派的基本单位`</b>`,它是比进程更小的能独立运行的基本单位.`<b>`线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)`</b>`,但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。`<br>`一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程 在运行中呈现出间断性。线程也有就绪 http://baike.baidu.com/view/654230.htm
    、阻塞 http://baike.baidu.com/view/497285.htm
    和运行 http://baike.baidu.com/view/1026025.htm
    三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。`<br>`线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行 http://baike.baidu.com/view/1026025.htm
    中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程 http://baike.baidu.com/view/65706.htm
    。`<br>`回到顶部 https://www.cnblogs.com/fanguangdexiaoyuer/p/10834737.html#_labelTop
    `<br>`

    - 原子性、可见性、有序性
  - 协程

    `<b>`协程是一种用户态的轻量级线程，协程的调度完全由`</b>`用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。`<br>`回到顶部 https://www.cnblogs.com/fanguangdexiaoyuer/p/10834737.html#_labelTop
    `<br>`
  - 进程、线程、协程的区别

    对于进程来说，子进程是父进程的复制品，从父进程那里获得父进程的数据空间，堆和栈的复制品。`<br>`而线程，相对于进程而言，是一个更加接近于执行体的概念，可以和同进程的其他线程之间直接共享数据，而且拥有自己的栈空间，拥有独立序列。`<br>`
  - 进程、线程共同点

    它们都能提高程序的并发度，提高程序运行效率和响应时间。线程和进程在使用上各有优缺点。 线程执行开销比较小，但不利于资源的管理和保护，而进程相反。同时，线程适合在SMP机器上运行，而进程可以跨机器迁移。`<br>`
  - 进程、线程不同点

    多进程中每个进程有自己的地址空间，线程则共享地址空间。`<br>`所有其他区别都是因为这个区别产生的。比如说：`<br>`

    - 1. 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间
    - 2. 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源
    - 3. 线程是处理器调度的基本单位,但进程不是
    - 4. 二者均可并发执行
    - 5. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制
    - 6. 速度。线程产生的速度快，通讯快，切换快，因为他们处于同一地址空间。
    - 7. 线程的资源利用率好。
    - 8. 线程使用公共变量或者内存的时候需要同步机制，但进程不用。

      而他们通信方式的差异也仍然是由于这个根本原因造成的。`<br>`
  - 线程、协程比较

    - 1. 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。
    - 2. 线程进程都是同步机制，而协程则是异步
    - 3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态

      回到顶部 https://www.cnblogs.com/fanguangdexiaoyuer/p/10834737.html#_labelTop
      `<br>`
  - 举一个多线程和多进程软件的例子

    Web服务器使用多线程的主要目的是为了处理大量的并发请求，利用I/O等待时间实现并发处理。`<br>`而图像处理使用多进程的主要目的是为了充分利用多核处理器的计算能力，同时处理多个图像，提高图像处理效率。`<br>`线程间共享数据：在多线程环境下，多个线程可能需要共享数据，而对共享数据的访问需要考虑线程安全和并发控制问题。在图像处理任务中，可能需要频繁地读写像素数据，而对共享数据的访问会带来额外的开销和复杂性。`<br>`因此图像处理用多进程。`<br>`
  - 浏览器页面为什么要用多进程？

    1 隔离性：每个标签页（Tab）通常运行在独立的进程中。这样做的好处是，如果一个标签页出现了问题（如崩溃或内存泄漏），不会影响其他标签页的运行。每个标签页之间相互隔离，提高了浏览器的稳定性和可靠性。`<br>`2 安全性：使用多进程可以在不同的进程中运行不同的网站内容，这有助于防止恶意网站对用户数据和系统进行攻击。浏览器可以对不同进程的访问进行权限隔离，提供更强的安全性保障。`<br>`3 并发处理：多进程可以实现并行处理多个任务，例如同时下载资源、渲染页面、处理JavaScript等。这样可以提高页面加载速度和响应性能。`<br>`4 利用多核处理器：现代计算机通常有多核处理器，使用多进程可以充分利用多核处理器的计算能力，提高浏览器的整体性能。`<br>`5 资源管理：每个进程可以独立分配资源，例如内存和CPU。这有助于在资源受限的情况下，更好地管理和分配资源，避免单个标签页耗尽所有资源影响其他标签页的运行。`<br>`
- 通信方式之间的差异

  因为那个根本原因，实际上只有进程间需要通信,同一进程的线程共享地址空间,没有通信的必要，但要做好同步/互斥,保护共享的全局变量。`<br>`而进程间通信无论是信号，管道pipe还是共享内存都是由操作系统保证的，是系统调用。`<br>`回到顶部 https://www.cnblogs.com/fanguangdexiaoyuer/p/10834737.html#_labelTop
  `<br>`

  - 进程通信
  - 管道(pipe)

    管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有`<b>`亲缘关系`</b>`的进程间使用。进程的亲缘关系通常是指父子进程关系。`<br>`
  - 有名管道 (namedpipe)

    有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。`<br>`
  - 信号量(semaphore)

    信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。`<br>`
  - 消息队列(messagequeue)

    消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。`<br>`
  - 信号 (sinal)

    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。`<br>`
  - 共享内存(shared memory)

    共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。`<br>`
  - 套接字(socket)

    套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。`<br>`回到顶部 https://www.cnblogs.com/fanguangdexiaoyuer/p/10834737.html#_labelTop
    `<br>`
- 线程间的通信方式

  - 锁机制：包括互斥锁、条件变量、读写锁

    互斥锁提供了以排他方式防止数据结构被并发修改的方法。
    读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
    条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。`<br>`
  - 信号量机制(Semaphore)

    包括无名线程信号量和命名线程信号量。`<br>`
  - 信号机制(Signal)

    类似进程间的信号处理。`<br>`线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。`<br>`
