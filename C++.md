# 面向对象三大特性
## 多态
### 虚函数的实现原理

  基类中声明了虚函数，编译器就会为这个类创建一个虚函数表。`<br>`继承的时候，会拷贝这个虚函数表到派生类，如果派生类中写了其他的虚函数，会加到自身虚函数表到后面；如果派生类中重写了虚函数，会替换虚函数表中的内容。`<br>`在父类指针指向子类对象时，调用虚函数会先匹配派生类的虚函数表。因此实现多态`<br>`
- 虚继承

  https://www.cnblogs.com/qrlozte/p/4168807.html`<br>`

# STL

- 迭代器

  - 迭代器失效

    - 对容器的操作影响了元素的存放位置，称为迭代器失效。

      - 当容器调用 `erase()`方法后，当前位置到容器末尾元素的所有迭代器全部失效。
      - 当容器调用 `insert()`方法后，当前位置到容器末尾元素的所有迭代器全部失效。
      - 如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。
      - 在deque容器的任何其他位置（除了首尾）进行 `插入`或 `删除`操作都将使指向该容器元素的所有迭代器失效；因为 vetor、deque 使用了连续分配的内存，`erase`操作删除一个元素导致后面所有的元素都会向前移动一个位置，这些元素的地址发生了变化，所以当前位置到容器末尾元素的所有迭代器全部失效。

        ```C++
        解决方法是利用erase方法可以返回下一个有效的 iterator，所以代码做如下修改即可：<br>// 在这里想把大于2的元素都删除
        for(auto it=q.begin();it!=q.end();)
        {
            if(<i>it>2)
            {
              it=q.erase(it); // 这里会返回指向下一个元素的迭代器，因此不需要再自加了
            }
            else
            {
              it++;
            }
        }
        而map、list这类容器erase当前iterator仅仅使得当前iterator失效，可以直接加加，或者像上面一样用erase（ite++）
        ```<br>
        ```
- push_back()和emplace_back()，区别是什么？

  push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。`<br>`

# 语言特性
## 回调函数

- 回调函数是什么，回调的本质
	- 回调函数的本质是函数指针（或函数引用），在某个函数执行完毕后，通过函数指针或函数引用调用另一个事先定义好的函数。
- 回调函数的执行过程如下：
1. 事先定义函数：首先，需要事先定义一个函数，作为回调函数的实际执行体。这个函数的参数和返回值要和回调函数的要求相匹配。
2. 注册回调：在程序的适当位置，通过函数指针或函数引用将预定义的函数注册为回调函数。这样，在特定的事件或条件触发时，可以调用回调函数。
3. 事件触发：当特定事件或条件满足时，程序会调用注册的回调函数，执行事先定义好的逻辑。

## sizeof & strlen

  ```C++
  int main(void)
  {
          char str[100] = "abcde";
          printf("sizeof(str) = %lu\n", sizeof(str));     //字节大小为100

          char str1[] = "abcde";
          printf("sizeof(str1) = %lu\n", sizeof(str1));   //字节大小为6

          char str2[] = "\0abcde";
          printf("sizeof(str2) = %lu\n", sizeof(str2));   //字节大小为7

          char str3[] = "\0ab\0c de";
          printf("sizeof(str3) = %lu\n", sizeof(str3));   //字节大小为9

          char str4[] = "abcde";
          printf("strlen(str4) = %lu\n", strlen(str4));   //字符串长度为5

          char str5[100] = "abcde";
          printf("strlen(str5) = %lu\n", strlen(str5));   //字符串长度为5

          char str6[] = "\0abcde";
          printf("strlen(str6) = %lu\n", strlen(str6));   //字符串长度为0

          char str7[] = "ab cde";
          printf("strlen(str7) = %lu\n", strlen(str7));   //字符串长度为6

          return 0;
  }
  ```<br>
  ```
## 指针
### 空指针
#### 什么是空指针
- NULL、nullptr
#### 空指针指向内存什么地方
- 逻辑地址0
#### 空指针异常的情况
- 一个指针指向的逻辑地址能够转换成正确的物理地址，就是正常的。
- 异常：无法转换为真实的物理地址。空指针的逻辑地址就指向其赋值分区，这个分区的逻辑地址没有对应的物理地址。因此异常。
#### 空指针赋值分区
- 进程的地址空间0x00000000到0x0000FFFF到闭区间，不能被动态内存分配器分配，不能访问，不能使用。
### 野指针
- 指向未初始化的内存空间。

# C++内存管理
## 如何构造一个类，使得其只能在堆上或只能在栈上分配内存？
- 只能在堆上分配内存，将构造函数或析构函数声明为private或protected
- 只能在栈上分配内存，只有使用new运算符对象才会建立在堆上，所以只要仅用new运算符就可以，将new运算符重载为private即可，同时delete也需要重载
## new和malloc有什么异/同
### 方法来源
#### new/delete
- 是C++的运算符，不需要头文件支持
#### malloc/free
- 是C++/C语言的标准库函数，需要库文件stdlib.h支持
### 申请内存时
#### new
- 申请失败会抛出异常，不会返回nullptr
- 申请内存时不用显示指定内存块大小
- 从自由存储区[[linux系统#^9ab37e]]为对象动态分配内存空间 ^1c29f3
> 自由存储区：C++中的一个抽象概念，defalut是堆，但可以重载运算符，使得自由存储区开在别的内存区域。
- new分为两个阶段。1. 申请内存； 2. 初始化（调用构造函数）。
- 类型安全
#### malloc
- 申请失败会返回NULL
- 申请内存时需要显示指定内存块大小
- 堆上动态分配空间
- 不是类型安全
#### 是否可以被重载
- new/delete：可以
- malloc：不行
### 相同点
- （同）delete/free被调用后，内存不会立即回收指针也不会指向空，因此释放完内存后，应该将该指针指向NULL，否则就成了野指针

## 内存块太小导致malloc和new内存分配失败，该怎么处理？

  - 对malloc来说，需要判断其是否返回空指针，如果是则马上return或exit
  - 对new来说，默认抛出异常，可以用try-catch处理
## 内存泄漏的场景

  - malloc和free未成对出现；new/new []和delete/delete []未成对出现
  - 在局部分配的内存，未在调用者函数体内释放
  - 在构造函数中动态分配内存，但未在析构函数中正确释放内存
  - 未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放释放相同内存的做法；
	  - 例如没有定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或赋值运算符，这样会使得两个对象包含指向同一内存空间的指针，就会多次释放同一内存空间
  - 没有将基类的析构函数设为虚函数。
	  - 假如基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数

## C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free

  - 理论上前者可以，但一般不这么写；后者不可以，free不能执行析构函数。


# 内存池

  - 内存池是一种内存分配方式，是在真正使用内存前，先申请分配一定数量的、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。
  - 通用内存分配和释放的缺点如下：

    - 使用malloc/new申请分配堆内存时系统需要根据最先匹配、最优匹配或其他算法在内存空闲表中查找一块空闲内存；使用free/delete释放堆内存时，系统可能需要合并空闲内存块，因此会产生额外开销
    - 频繁使用时会产生大量内存碎片，从而降低程序运行效率
    - 造成内存泄漏
  - 内存池是代替直接调用malloc/free、new/delete进行内存管理的常用方法，当申请内存空间时，会从内存池中查找合适的内存块，而不是直接向操作系统申请。
  - 内存池技术的优点如下：

    - 堆内存碎片很少
    - 内存申请/释放比malloc/free快
    - 检查任何一个指针是否在内存池中
    - 写一个堆转储（Heap-Dump）到硬盘
    - 内存泄漏检测。当没有释放分配的内存时，内存池会抛出一个断言。
  - 内存池可以分为不定长内存池和定长内存池两类。不定长内存池的典型实现包括(Apache Portable Runtime中的)apr_pool和(GNU lib C中的)obstack，而定长内存池的实现则有boost_pool等。对于不定长内存池，不需要为不同的数据类型创建不同的内存池，缺点是无法将分配出的内存回收到池内；对于定长内存池，在使用完毕后，可以将内存归还到内存池中，但需要为不同类型的数据结构创建不同的内存池，需要内存的时候要从相应的内存池中申请内存。

### C++小知识点

inline和static的区别
`static`静态函数的作用于仅限于此文件，所以不用担心与同名的内部函数冲突。c++类的静态成员是该类型的所有对象所共享，存储在数据段，类的成员函数没有隐含的this指针，使用类名::函数名直接调用类的成员函数，Date::Display()
`const`const对象只能访问const成员函 数，而非const对象可以访问任意的成员函数，包括const成员函数；const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的；  const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检 查
`inline`c++编译时会在调用内联函数的地方展开，没有函数压栈的开销，提高了效率。1、inline函数的声明&定义放在一起。 2、代码长或有递归或循环的不适宜用。3、对编译器只是一个建议。4、定义在类内的成员函数默认为内联函数
(1)`final`和 `override`的作用？`final`为什么能提高代码执行效率？
`override`：保证在派生类中声明的重载函数，与基类的虚函数有相同的签名，核心作用就是用于编译期代码检查。
`final`：阻止类的进一步派生和虚函数的进一步重写，同时也是一种名为去虚拟化的优化技巧，相当于把运行期多态转换为了编译期多态，提高了执行效率。
(2)`static`的3种作用？
修饰局部变量，这意味着该变量只被初始化一次，并保留其值直到程序结束。
修饰全局变量，这意味着该变量具有文件作用域。
修饰成员变量，这意味着变量不会绑定到对象上。
(3)`thread_local`作用和原理？
`thread_local`用来定义一个线程本地变量，每个线程都拥有自己的 `thread_local`对象副本，这些副本放在各个线程自己的TLS空间。`thread_local`描述的对象在thread开始时分配，而在thread结束时释放。
(4)一个变量可以既是 `const`又是 `volatile`吗？
可以。`const`的作用是告诉编译器，编译期间不允许对变量进行修改，编译器在编译期间往往会对 `const`变量执行一种名为字符替换的优化。`volatile`的作用是告诉编译器，第一，编译期间不要对该变量进行优化；第二，运行期间，每次必须从内存中加载变量的值。`const volatile`表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，每次必须从内存中加载变量的值。
(5)`NULL`和 `nullptr`区别？为什么要引入 `nullptr`？
主流编译器中，`NULL` 实际上是一个整数常量，被定义为 `0`，在 C++11 之前，当我们想要将一个指针初始化为空时，我们通常使用 `NULL`；`nullptr` 是 C++11 中引入的新的关键字，专门用于表示空指针，它不是整数类型，而是特殊的指针类型 `nullptr_t`。之所以引入 `nullptr`，第一，`NULL`是整数类型，用户调用foo(NULL)的时候，不能区分调用的是 `foo(int)`还是 `foo(int)`函数；第二，主流编译器中 `NULL`值为 `0`，通过 `0`表示一个无效地址，但是有的架构下，`0`地址有特定用途，而 `nullptr`指向的永远是一个无效地址。
(6)为什么 `noexcept`能提高性能？
使用 `noexcept` 可以让编译器对代码进行优化，从而提高代码的性能。具体来说，为实现异常捕获的功能，c++引入了“栈回退”机制，编译器在编译函数的时候，会为函数生成额外的叫做“栈回退”的代码，使用 `noexcept` 可以避免生成额外的代码来处理异常情况，这样可以减少代码量和执行时间。关闭异常捕获是比较危险的行为，一般只建议用在构造函数。
(7)`delete[]`是怎样知道数组长度的？
没有标准实现，一种常见的实现方法是，申请内存时，会在返回的指针前面存放这段内存的大小，调用 `delete[]`的时候，就可以知道数组长度了。
(8)`new`，`placement new`，`operator new`的区别？怎么在把对象new在栈上？
`operator new`作用是分配一块内存，`placement new`作用是在已分配内存地址处，创建一个对象，`new`的作用则等于 `operator new` + `placement new`。先在栈上声明一个数组，然后通过 `placement new` 在这段地址处创建对象，这就实现了在栈上new一个对象。
(9)`__cdecl`和 `__stdcall`区别？
都是 Microsoft Visual C++ 中用于声明函数调用约定的关键字。`__cdecl` 是 C/C++ 默认的调用约定，在 `__cdecl` 调用约定下，参数从右往左入栈，由调用方负责清理堆栈；在 `__stdcall` 调用约定下，函数参数从右向左压入堆栈中，函数堆栈的清除工作由被调用方负责。这些关键字主要用于跨语言调用，以确保参数传递和堆栈清理的一致性。
(10)重载类的delete运算符，delete的时候会发生什么？
`new`的默认行为是先分配一段内存，然后调用对象的构造函数，把对象创建在这段内存上；`delete`的默认行为是先调用析构函数，然后释放内存。重载全局 `new`和 `delete`运算符号，会修改所有的 `new`和 `delete`内存行为，重载类的 `new`和 `delete`运算符，会修改针对这个类的 `new`和 `delete`内存行为。
(11)函数调用压栈流程？
不同系统下压栈的具体操作不同，但大致都有这么个过程：函数调用的时候，把被调用函数参数压栈，把预留的返回值存放位置压栈，把当前函数上下文，比如栈地址相关的寄存器和指令地址相关的寄存器内容压栈，函数返回的时候，弹出函数参数和返回值，弹出函数上下文内容到寄存器，恢复现场。
(12)声明和定义的作用，从编译角度说明？
声明的作用主要两点，第一，提供链接时需要的符号信息，这些信息存储在目标文件的重定位表和符号表当中；第二，提供类型大小信息，c++采取的是单文件编译策略，当不知道某个符号对应类型的定义的时候，需要在链接前预留出合适大小的内存空间，供链接时填充。
(13)现代大部分编程语言都没有头文件，c++为什么有头文件？头文件和模块的优劣比较？#include和前置声明的区别？
c++和采取模块机制的编程语言的一个重大区别在于，c++把函数和变量签名这部分信息保存在头文件内，而采取模块机制的编程语言把这部分信息保存在库内。头文件和模块相比，会拷贝很多无用的声明信息到当前文件内，从而导致编译非常慢，另一个缺点就是头文件机制很容易引发符号重定义错误。c++之所以采用头文件机制是因为，早期计算机的内存资源非常珍贵，如果把函数和变量签名信息都保存到二进制库中，会浪费更多的内存资源。`#include`和前置声明本质上都是声明，区别在于 `#include`在预处理期间做了一次拷贝声明的操作，前置声明的优势在于可以按需导入函数，而且可以解决循环依赖问题。
(14)c++11为什么引入枚举类？
传统的 C++ 枚举类型会将枚举值暴露在命名空间中，容易造成命名冲突，而枚举类则通过引入了作用域限定符来解决这个问题。其次，传统的 C++ 枚举类型是基于整数的，可以进行隐式的类型转换和比较操作，这可能会导致一些意想不到的错误，而枚举类则可以避免这个问题，因为它们只能进行显式的类型转换和比较操作。
(15)程序是从 `main` 函数开始执行的吗？
不是，程序在执行前，会经历一个从磁盘加载程序到内存的过程，这个过程会执行非静态全局变量的初始化。
(16)虚函数怎么实现的？真的更慢吗？
虚函数是通过虚函数表实现的，每个类都有自己的虚表，对象的首地址处存放有指向虚表的指针。当具体调用哪个虚函数可以在编译期间确定的时候，虚函数不一定更慢。
(17)构造函数、析构函数、重载运算符函数可以是虚函数吗？类成员函数模板可以是虚函数吗？
析构函数和重载运算符函数都可以是虚函数，而构造函数不能是虚函数，这是因为构造函数是用来创建对象的，在创建对象期间，存放虚函数地址的虚表还没有创建完成，如果直接调用虚函数会引发异常。类成员函数模板不能是虚函数，因为C++在链接前是不知道成员函数模板被实例化多少次的，这就会导致编译器无法在编译期间确定虚表的大小。
(18)成员函数指针和普通函数指针区别？
普通函数指针属于指针类型，成员函数指针不是指针类型。通常来说，函数指针的长度等于机器字长，而成员函数指针长度比函数指针更长，其内部存放了对象地址和成员函数地址信息。在没有给出对象地址的情况下，调用成员函数指针会报错。
(19)各种变量存放在虚拟内存的哪个分区？
直接声明的变量、函数实参存储在栈区；new创建的对象，较小的对象存放在堆 区，较大的对象存放在共享内存区；常量和静态变量存放在静态存储区中的非代码区；所有函数存放在静态存储区中的代码区；字符常量也存放在代码区。
(20)对象的内存模型？发生继承时候的对象内存模型？
成员函数存放在代码区；静态成员变量存放在静态存储区；普通成员变量存放在对象内，且按照声明顺序依次存放；如果类声明了虚函数，那么对象的首地址处往往会存放一个指向虚表的指针，另外访问权限关键字可能会影响对象的内存布局，至于怎么影响，标准没有规定，不同编译器的实现肯不同。发生继承的时候，基类对象怎样存放，标准也没有规定，一般是按照继承顺序依次存放在内存当中，每个对象都可以有自己的虚表。
(21)什么是标准布局类型和 `trivial`类型？有什么用？
引入标准布局类型是为了向C语言兼容，使得用户能够通过对象第一个成员的指针类型指向对象；引入 `trivial`类型是为了提高对象初始化效率，`memcpy`比构造函数初始化效率效率更高。不考虑继承，一个类没有虚函数、所有非静态变量的访问权限相同，则是标准布局类型；不考虑继承，一个类没有自定义构造、自定义析构函数，没有虚函数，则是 `trivial`类型。
(22)什么是类型擦除？实现方式？
类型擦除是一种，使得不同类型变量能够得到统一处理的技术。实现方式上可分为静态类型擦除了动态类型擦除，静态类型擦除通过模板或者宏实现，动态类型擦除可通过继承虚函数或者void类型实现。
(23)什么是多态？实现方式？
多态指的是一种相同的形式表现出不同行为的概念，分为静态多态和动态多态。代码层面，静态多态通过重载（overload）实现，动态多态通过覆盖（override）实现；原理层面，静态多态通过name mangling实现，动态多态通过虚表实现。
(24)`inline`的作用和原理？
c++17以前，`inline`关键字主要有两个作用：第一，作为内联优化建议，告诉编译器在调用处展开函数，只不过是否展开函数还是由编译器决定；第二，解决符号重定义问题，不同文件内定义了同签名的函数，若被inline关键字修饰，则不会引发符号重定义错误。c++17开始，inline只保留第二个作用，若用户希望函数内联展开，则可以使用 `__attribute((always_inline))__` 关键字，它是 GCC 和 Clang 中的一个扩展，用于强制内联函数。。原理上，第一，内联展开相比于普通函数调用，少了函数上下文压栈的过程，因此效率更高，缺点就是容易引起代码膨胀。第二，被 `inline`关键字修饰的函数名，编译期间会被标记为weak符号，链接目标文件的时候，多个同签名weak符号不会引发编译器报错，运行期间，会选取其中一个函数进行调用。
(25)`inline`用作内联展开这层含义的时候，构造函数、析构函数、虚函数可以被 `inline`修饰吗？可以获取 `inline`函数的指针吗？`static inline`和 `extern inline`含义？
任何函数都可以被 `inline`修饰，包括构造函数、析构函数、虚函数。这里提一下为什么虚函数可以内联，`inline`函数涉及到的是编译期解析，虚函数地址大多数情况下在运行期解析，但是某些情况下，具体调用哪个虚函数可以在编译期间确定，这个时候虚函数就能内联展开了。`inline`只作为内联建议，是否展开由编译器决定，因此是可以获取 `inline`函数指针的。`static inline`指的是具有文件作用域的 `inline`函数；`extern inline`作用比较特殊，外部单元把它当作普通函数进行调用，同单元内把它当作 `inline`函数调用。
(26)`malloc`和 `new`区别？`malloc`实现原理？`free`后，内存被释放了吗？
`malloc`只分配一段内存，`new`会先分配一段内存，然后在这段内存上创建对象。`malloc`实现上，先从用户态切换到内核态，分配一段空闲物理内存，接着在虚拟内存堆空间或者共享内存空间分配一段虚拟内存，然后填充页表，把虚拟内存映射到物理内存，最后返回用户态。`free`后，内存没有被立即释放，而是保留在内存当中，作为内存池的一部分供下次使用。
(27)谈谈lambda函数？
lambda函数可以看作是函数对象的语法糖，可以随地定义和调用。可通过lambda和智能指针实现闭包，c++17以前，lambda不支持 `this`捕获，c++17开始支持 `this`捕获。
(28)`union`和 `struct`和 `class`的区别？
`struct`和 `class`都可以用来定义类，`struct`成员默认 `public`，`class`成员默认 `private`，只不过从语义上来说，建议用 `struct`定义数据块，`class`定义类。`struct` 每个成员变量都有自己的内存地址；`union` 中的每个成员变量都占用相同的内存单元，并且只有最后赋值的成员变量所占用的内存单元才会被真正分配。
(29)什么是零三五原则？
零之法则：对于不需要通过析构函数回收资源的类，只定义普通构造函数。
三之法则：如果某个类需要用户定义析构函数回收资源，那么这个类除了要定义普通构造函数外，也一定要定义复制构造函数、赋值运算函数。
五之法则：因为用户定义的析构函数、复制构造函数或复制赋值运算符的存在会阻止移动构造函数和移动赋值运算符的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数
(30)C++可调用类型有哪些？
函数指针、函数对象、lambda表达式、成员函数指针。
(31)为什么把析构函数定义为虚函数？
解决 `delete` 指向子类对象的基类指针的时候，只析构基类、不析构子类的问题。
(32)构造函数和析构函数的调用顺序？
创建对象过程，先调用基类的构造函数，然后依次调用类非静态成员的构造函数，最后调用自己的构造函数；销毁对象过程，先调用自己的析构函数，然后依次调用非静态成员的析构函数，最后调用基类的析构函数。
(33)指针和引用的区别？
引用和指针在汇编层面都是内存地址，引用可以看作是指针常量，只能在声明的时候初始化，相比于指针，引用的优势在于编译器帮我们检查地址是否初始化。
(34)符号重定义的解决方法？
通过 `extern`，`static`，`inline`，`const`关键字都可以解决符号重定义问题，也可以通过命名空间、前置声明、`#ifndef`和 `#pragma once`宏解决这个问题。
(35)四种指针类型转换的区别？
`reinterpret_cast`用于任意指针（引用）类型之间的转换，不进行类型检查。`static_cast`用于基类和子类指针（引用）之间的转换，编译期进行类型检查。`dynamic_cast`用于基类和子类指针（引用）之间的转换，运行期进行类型检查。`const_cast`用于指针（引用）类型，用于删除限定符，不进行类型检查。
(36)知道什么是RVO吗？
RVO是一种返回值优化手段，它通过避免创建临时对象来提高代码性能。当一个函数返回一个非引用类型的变量时，编译器会尝试将该对象直接构造在调用者的栈空间中，而不是为该对象分配新的内存并在函数返回后再将其拷贝到调用者的栈空间中。
(37)RTTI的实现原理？
RTTI指的是运行时类型识别，通过虚表实现，指向类型信息的指针存放在虚表上。
(38)extern C的作用？
`extern "C"` 是 C++ 提供的一个关键字，用于指示编译器将某个函数或变量的名称按照 C 语言的方式进行处理，以便与C语言进行交互。其原理上就是关闭编译器的name mangling。
(39)可以在运行时访问private成员吗？
可以，访问权限关键字只在编译期有效，运行期是没有访问权限关键字这些概念的，可以在运行时访问对象内的任何成员。
(40)C++的编译流程？
先预处理，然后编译成目标文件，接着把目标文件链接成库文件或者可执行文件。
(41)动态库和静态库的区别？知道动态库延迟加载优化吗？
链接动态库和静态库的时候，静态库会被复制到可执行程序当中，而动态库不会。相比动态库，静态库的执行效率更高，但占用磁盘空间更多，不方便更新。动态库的延迟加载指的是，在运行时按需加载动态链接库中的函数和数据，而不是在启动的时候加载库函数和数据，从而降低启动时间，在linux系统下，延迟加载是通过PLT表和GOT表配合实现的。
(42)智能指针是什么？几种智能指针的区别？
智能指针是RAII思想的一种应用，`shared_ptr`是最常用的智能指针，但是，第一，效率低，可以通过在特定场合使用 `unique_ptr`弥补这点；第二，有循环引用的问题，故引入 `weak_ptr`；第三，不能直接封装this并返回，否则会引起引用计数错误，故引入 `enable_shared_from_this`。
(43)四种智能指针的简单实现？
不考虑删除器的实现，`unique_ptr`内部封装一个指针，在构造函数内把地址传给指针，析构函数内销毁指针指向的对象；`shared_ptr`内部封装一个指针，和一个存放在堆空间的引用计数，重新实现构造、拷贝构造、赋值构造、析构函数，每次调用构造函数、赋值构造函数、拷贝构造函数的时候，通过原子操作，对引用计数加1，每次调用析构函数，通过原子操作对引用计数减1，计数为0则销毁对象；`weak_ptr`实现和 `shared_ptr`类似，不同在于它不影响引用计数；`enable_shared_from_this`通过CRTP实现。
(44)什么是左值和右值？它们是C++11才有的吗？`string literal`是左值还是右值？`i++`和 `++i`是左值还是右值
左值是可以取地址的值，右值是不可取地址的值，右值之所以不能取地址，往往是因为这些值可能在寄存器上、可能是指令的一部分、可能是栈上的匿名变量。左右值是C语言出现开始，一直都有的概念，只是没有给他们明确下定义。`string literal`是左值，`++i`是返回值是 `i`本身，是左值，`i++`会返回一个临时变量，是右值。
(45)什么是左右值引用？和左右值有关系吗？右值引用适合什么场景下用？
左值引用和右值引用在汇编层面都是地址，右值引用的出现是伴随着移动构造函数出现的，之所以引入右值引用类型的语法，是为了区分拷贝构造函数和移动构造函数，更准确地来说是为了区分深拷贝和浅拷贝。只有右值才可以赋值给右值引用，但是右值和右值引用没有严格意义上的关系，把右值赋值给右值引用往往是不合理的，反而会降低运行效率，不要把字面值赋值给右边值引用，不要以右值引用的方式返回函数返回值。右值引用仅仅适用于把将亡值传递给函数参数这类场景。
(46)基本类型的长度？
这些长度可能会因编译器、操作系统和计算机体系结构的不同而有所变化。`char`长度是1字节；`short`长度至少2字节，大多情况下2字节；`int`长度至少2字节，大多数情况下4字节；`long int`长度大于等于 `int`长度；`float`长度4字节；`double`长度8字节。所以为了移植性，一般不建议直接使用这些类型，建议使用 `int8_t`，`int16_t`，`int32_t`等类型。
(47)内存对齐规则？为什么要内存对齐？
内存对齐有两个要求，第一，C++中有对齐系数这个概念，任何类型在内存中的首地址必须是自身对齐系数的整数倍，基本类型的对齐系数等于自身大小，结构体类型的内存对齐系数等于内存占用最大的基本类型成员的大小；第二，结构体内类型，相对于结构体首地址的偏移必须等于自身对齐系数的整数倍。引入内存对齐，是为了减少CPU访问内存数据的次数，提高取数据的效率。
(48)通过指针访问数组，系统是如何知道指针越界的？
编译器编译代码期间会增加额外的代码用于检测数组是否越界。生成下标越界检查代码，C语言默认关闭；C++默认开启。
(49)断言是什么？断言和条件语句的优劣？
断言用于在代码编译或者执行期间检查特定条件是否成立，不成立则报错终止。静态断言和动态断言是两种不同类型的断言。静态断言在代码编译期间进行验证，并在发现问题时引发编译时错误；动态断言在代码运行期间进行验证，并在发现问题时引发异常或错误。C++内，动态断言通常只在调试模式下启用，而在发布模式下会被忽略。断言相比于条件语句，效率更高，但降低了程序安全性。
(50)继承和组合的优劣？
继承和组合都是代码复用的方案，继承的耦合性更高，但提供了更多复用特性，比如 `public`和 `private`复用、比如多态。

  `static`静态函数的作用于仅限于此文件，所以不用担心与同名的内部函数冲突。c++类的静态成员是该类型的所有对象所共享，存储在数据段，类的成员函数没有隐含的this指针，使用类名::函数名直接调用类的成员函数，Date::Display()`<br>const`const对象只能访问const成员函 数，而非const对象可以访问任意的成员函数，包括const成员函数；const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的；  const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检 查`<br>inline`c++编译时会在调用内联函数的地方展开，没有函数压栈的开销，提高了效率。1、inline函数的声明&定义放在一起。 2、代码长或有递归或循环的不适宜用。3、对编译器只是一个建议。4、定义在类内的成员函数默认为内联函数`<br><b>`(1)`<i><i>``<b>final``<i><b>``<i>`和`<i></b>``</i>override``<i><b>``<i>`的作用？`<i></i>``</b>final``<b><b>`为什么能提高代码执行效率？`</b><br>``override`：保证在派生类中声明的重载函数，与基类的虚函数有相同的签名，核心作用就是用于编译期代码检查。`final`：阻止类的进一步派生和虚函数的进一步重写，同时也是一种名为去虚拟化的优化技巧，相当于把运行期多态转换为了编译期多态，提高了执行效率。`<br><b>`(2)`<i><b>``<i>static``<b><b>`的3种作用？`</b><br>`修饰局部变量，这意味着该变量只被初始化一次，并保留其值直到程序结束。
  修饰全局变量，这意味着该变量具有文件作用域。
  修饰成员变量，这意味着变量不会绑定到对象上。`<br><b>`(3)`<i><b>``<i>thread_local``<b><b>`作用和原理？`</b><br>``thread_local`用来定义一个线程本地变量，每个线程都拥有自己的 `thread_local`对象副本，这些副本放在各个线程自己的TLS空间。`thread_local`描述的对象在thread开始时分配，而在thread结束时释放。`<br><b>`(4)一个变量可以既是`</b><b>``const<i>``<b><i>`又是`<i><i>``<b>volatile``<b><b>`吗？`</b><br>`可以。`const`的作用是告诉编译器，编译期间不允许对变量进行修改，编译器在编译期间往往会对 `const`变量执行一种名为字符替换的优化。`volatile`的作用是告诉编译器，第一，编译期间不要对该变量进行优化；第二，运行期间，每次必须从内存中加载变量的值。`const volatile`表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，每次必须从内存中加载变量的值。`<br><b>`(5)`<i><i>``<i><i>``NULL<i>``<i><i>``<i>`和`<i><i>``<i><i>``nullptr<i>``<i><i>``<i>`区别？为什么要引入`<i><i>``<i><i>``nullptr<i>``<i><i>``<i>`？`</i></i>``<br>`主流编译器中，`NULL` 实际上是一个整数常量，被定义为 `0`，在 C++11 之前，当我们想要将一个指针初始化为空时，我们通常使用 `NULL`；`nullptr` 是 C++11 中引入的新的关键字，专门用于表示空指针，它不是整数类型，而是特殊的指针类型 `nullptr_t`。之所以引入 `nullptr`，第一，`NULL`是整数类型，用户调用foo(NULL)的时候，不能区分调用的是 `foo(int)`还是 `foo(int<i>)`函数；第二，主流编译器中 `NULL`值为 `0`，通过 `0`表示一个无效地址，但是有的架构下，`0`地址有特定用途，而 `nullptr`指向的永远是一个无效地址。`<br><b>`(6)为什么`</b><b>``noexcept<b>``<b>`能提高性能？`</b><br>`使用 `noexcept` 可以让编译器对代码进行优化，从而提高代码的性能。具体来说，为实现异常捕获的功能，c++引入了“栈回退”机制，编译器在编译函数的时候，会为函数生成额外的叫做“栈回退”的代码，使用 `noexcept` 可以避免生成额外的代码来处理异常情况，这样可以减少代码量和执行时间。关闭异常捕获是比较危险的行为，一般只建议用在构造函数。`<br><b>`(7)`<i><b>``<i>delete[]``<b><b>`是怎样知道数组长度的？`</b><br>`没有标准实现，一种常见的实现方法是，申请内存时，会在返回的指针前面存放这段内存的大小，调用 `delete[]`的时候，就可以知道数组长度了。`<br><b>`(8)`<i><b>``<i>new``<i></b>``<i>`，`<b><i>``<i>placement new``<i><i>``<b>`，`</b></i>``</i>operator new``<b><b>`的区别？怎么在把对象new在栈上？`</b><br>``operator new`作用是分配一块内存，`placement new`作用是在已分配内存地址处，创建一个对象，`new`的作用则等于 `operator new` + `placement new`。先在栈上声明一个数组，然后通过 `placement new` 在这段地址处创建对象，这就实现了在栈上new一个对象。`<br><b>`(9)`<i><i>``<b>__cdecl``<i><b>``<i>`和`<i></b>``</i>__stdcall``<b><b>`区别？`</b><br>`都是 Microsoft Visual C++ 中用于声明函数调用约定的关键字。`__cdecl` 是 C/C++ 默认的调用约定，在 `__cdecl` 调用约定下，参数从右往左入栈，由调用方负责清理堆栈；在 `__stdcall` 调用约定下，函数参数从右向左压入堆栈中，函数堆栈的清除工作由被调用方负责。这些关键字主要用于跨语言调用，以确保参数传递和堆栈清理的一致性。`<br><b>`(10)重载类的delete运算符，delete的时候会发生什么？`</b><br>``new`的默认行为是先分配一段内存，然后调用对象的构造函数，把对象创建在这段内存上；`delete`的默认行为是先调用析构函数，然后释放内存。重载全局 `new`和 `delete`运算符号，会修改所有的 `new`和 `delete`内存行为，重载类的 `new`和 `delete`运算符，会修改针对这个类的 `new`和 `delete`内存行为。`<br><b>`(11)函数调用压栈流程？`</b><br>`不同系统下压栈的具体操作不同，但大致都有这么个过程：函数调用的时候，把被调用函数参数压栈，把预留的返回值存放位置压栈，把当前函数上下文，比如栈地址相关的寄存器和指令地址相关的寄存器内容压栈，函数返回的时候，弹出函数参数和返回值，弹出函数上下文内容到寄存器，恢复现场。`<br><b>`(12)声明和定义的作用，从编译角度说明？`</b><br>`声明的作用主要两点，第一，提供链接时需要的符号信息，这些信息存储在目标文件的重定位表和符号表当中；第二，提供类型大小信息，c++采取的是单文件编译策略，当不知道某个符号对应类型的定义的时候，需要在链接前预留出合适大小的内存空间，供链接时填充。`<br><b>`(13)现代大部分编程语言都没有头文件，c++为什么有头文件？头文件和模块的优劣比较？#include和前置声明的区别？`</b><br>`c++和采取模块机制的编程语言的一个重大区别在于，c++把函数和变量签名这部分信息保存在头文件内，而采取模块机制的编程语言把这部分信息保存在库内。头文件和模块相比，会拷贝很多无用的声明信息到当前文件内，从而导致编译非常慢，另一个缺点就是头文件机制很容易引发符号重定义错误。c++之所以采用头文件机制是因为，早期计算机的内存资源非常珍贵，如果把函数和变量签名信息都保存到二进制库中，会浪费更多的内存资源。`#include`和前置声明本质上都是声明，区别在于 `#include`在预处理期间做了一次拷贝声明的操作，前置声明的优势在于可以按需导入函数，而且可以解决循环依赖问题。`<br><b>`(14)c++11为什么引入枚举类？`</b><br>`传统的 C++ 枚举类型会将枚举值暴露在命名空间中，容易造成命名冲突，而枚举类则通过引入了作用域限定符来解决这个问题。其次，传统的 C++ 枚举类型是基于整数的，可以进行隐式的类型转换和比较操作，这可能会导致一些意想不到的错误，而枚举类则可以避免这个问题，因为它们只能进行显式的类型转换和比较操作。`<br><b>`(15)程序是从`</b><b>``main<i>``<b><i>` 函数开始执行的吗？`<b><br>`不是，程序在执行前，会经历一个从磁盘加载程序到内存的过程，这个过程会执行非静态全局变量的初始化。`<br><b>`(16)虚函数怎么实现的？真的更慢吗？`</b><br>`虚函数是通过虚函数表实现的，每个类都有自己的虚表，对象的首地址处存放有指向虚表的指针。当具体调用哪个虚函数可以在编译期间确定的时候，虚函数不一定更慢。`<br><b>`(17)构造函数、析构函数、重载运算符函数可以是虚函数吗？类成员函数模板可以是虚函数吗？`</b><br>`析构函数和重载运算符函数都可以是虚函数，而构造函数不能是虚函数，这是因为构造函数是用来创建对象的，在创建对象期间，存放虚函数地址的虚表还没有创建完成，如果直接调用虚函数会引发异常。类成员函数模板不能是虚函数，因为C++在链接前是不知道成员函数模板被实例化多少次的，这就会导致编译器无法在编译期间确定虚表的大小。`<br><b>`(18)成员函数指针和普通函数指针区别？`</b><br>`普通函数指针属于指针类型，成员函数指针不是指针类型。通常来说，函数指针的长度等于机器字长，而成员函数指针长度比函数指针更长，其内部存放了对象地址和成员函数地址信息。在没有给出对象地址的情况下，调用成员函数指针会报错。`<br><b>`(19)各种变量存放在虚拟内存的哪个分区？`</b><br>`直接声明的变量、函数实参存储在栈区；new创建的对象，较小的对象存放在堆 区，较大的对象存放在共享内存区；常量和静态变量存放在静态存储区中的非代码区；所有函数存放在静态存储区中的代码区；字符常量也存放在代码区。`<br><b>`(20)对象的内存模型？发生继承时候的对象内存模型？`</b><br>`成员函数存放在代码区；静态成员变量存放在静态存储区；普通成员变量存放在对象内，且按照声明顺序依次存放；如果类声明了虚函数，那么对象的首地址处往往会存放一个指向虚表的指针，另外访问权限关键字可能会影响对象的内存布局，至于怎么影响，标准没有规定，不同编译器的实现肯不同。发生继承的时候，基类对象怎样存放，标准也没有规定，一般是按照继承顺序依次存放在内存当中，每个对象都可以有自己的虚表。`<br><b>`(21)什么是标准布局类型和`</b><b>``trivial<b>``<b>`类型？有什么用？`</b><br>`引入标准布局类型是为了向C语言兼容，使得用户能够通过对象第一个成员的指针类型指向对象；引入 `trivial`类型是为了提高对象初始化效率，`memcpy`比构造函数初始化效率效率更高。不考虑继承，一个类没有虚函数、所有非静态变量的访问权限相同，则是标准布局类型；不考虑继承，一个类没有自定义构造、自定义析构函数，没有虚函数，则是 `trivial`类型。`<br><b>`(22)什么是类型擦除？实现方式？`</b><br>`类型擦除是一种，使得不同类型变量能够得到统一处理的技术。实现方式上可分为静态类型擦除了动态类型擦除，静态类型擦除通过模板或者宏实现，动态类型擦除可通过继承虚函数或者void类型实现。`<br><b>`(23)什么是多态？实现方式？`</b><br>`多态指的是一种相同的形式表现出不同行为的概念，分为静态多态和动态多态。代码层面，静态多态通过重载（overload）实现，动态多态通过覆盖（override）实现；原理层面，静态多态通过name mangling实现，动态多态通过虚表实现。`<br><b>`(24)`<i><b>``<i>inline``<b><b>`的作用和原理？`</b><br>`c++17以前，`inline`关键字主要有两个作用：第一，作为内联优化建议，告诉编译器在调用处展开函数，只不过是否展开函数还是由编译器决定；第二，解决符号重定义问题，不同文件内定义了同签名的函数，若被inline关键字修饰，则不会引发符号重定义错误。c++17开始，inline只保留第二个作用，若用户希望函数内联展开，则可以使用 `__attribute((always_inline))__` 关键字，它是 GCC 和 Clang 中的一个扩展，用于强制内联函数。。原理上，第一，内联展开相比于普通函数调用，少了函数上下文压栈的过程，因此效率更高，缺点就是容易引起代码膨胀。第二，被 `inline`关键字修饰的函数名，编译期间会被标记为weak符号，链接目标文件的时候，多个同签名weak符号不会引发编译器报错，运行期间，会选取其中一个函数进行调用。`<br><b>`(25)`<i><i>``<b>inline``<i><b>``<i>`用作内联展开这层含义的时候，构造函数、析构函数、虚函数可以被`<i></b>``</i>inline``<i><b>``<i>`修饰吗？可以获取`<i></i>``</b>inline``<i><b>``<i>`函数的指针吗？`<i><i>``<b>static inline``<i><b>``<i>`和`<i><i>``<b>extern inline``<b><b>`含义？`</b><br>`任何函数都可以被 `inline`修饰，包括构造函数、析构函数、虚函数。这里提一下为什么虚函数可以内联，`inline`函数涉及到的是编译期解析，虚函数地址大多数情况下在运行期解析，但是某些情况下，具体调用哪个虚函数可以在编译期间确定，这个时候虚函数就能内联展开了。`inline`只作为内联建议，是否展开由编译器决定，因此是可以获取 `inline`函数指针的。`static inline`指的是具有文件作用域的 `inline`函数；`extern inline`作用比较特殊，外部单元把它当作普通函数进行调用，同单元内把它当作 `inline`函数调用。`<br><b>`(26)`<i><i>``<b>malloc``<i><b>``<i>`和`<i></b>``</i>new``<i><b>``<i>`区别？`<i></i>``</b>malloc``<i><b>``<i>`实现原理？`<i><i>``<b>free``<b><b>`后，内存被释放了吗？`</b><br>``malloc`只分配一段内存，`new`会先分配一段内存，然后在这段内存上创建对象。`malloc`实现上，先从用户态切换到内核态，分配一段空闲物理内存，接着在虚拟内存堆空间或者共享内存空间分配一段虚拟内存，然后填充页表，把虚拟内存映射到物理内存，最后返回用户态。`free`后，内存没有被立即释放，而是保留在内存当中，作为内存池的一部分供下次使用。`<br><b>`(27)谈谈lambda函数？`</b><br>`lambda函数可以看作是函数对象的语法糖，可以随地定义和调用。可通过lambda和智能指针实现闭包，c++17以前，lambda不支持 `<i>this`捕获，c++17开始支持 `<i>this`捕获。`<br><b>`(28)`<i><i>``<b>union``<i><b>``<i>`和`<i></b>``</i>struct``<i><b>``<i>`和`<i></i>``</b>class``<b><b>`的区别？`</b><br>``struct`和 `class`都可以用来定义类，`struct`成员默认 `public`，`class`成员默认 `private`，只不过从语义上来说，建议用 `struct`定义数据块，`class`定义类。`struct` 每个成员变量都有自己的内存地址；`union` 中的每个成员变量都占用相同的内存单元，并且只有最后赋值的成员变量所占用的内存单元才会被真正分配。`<br><b>`(29)什么是零三五原则？`</b><br>`零之法则：对于不需要通过析构函数回收资源的类，只定义普通构造函数。
  三之法则：如果某个类需要用户定义析构函数回收资源，那么这个类除了要定义普通构造函数外，也一定要定义复制构造函数、赋值运算函数。
  五之法则：因为用户定义的析构函数、复制构造函数或复制赋值运算符的存在会阻止移动构造函数和移动赋值运算符的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数`<br><b>`(30)C++可调用类型有哪些？`</b><br>`函数指针、函数对象、lambda表达式、成员函数指针。`<br><b>`(31)为什么把析构函数定义为虚函数？`</b><br>`解决 `delete` 指向子类对象的基类指针的时候，只析构基类、不析构子类的问题。`<br><b>`(32)构造函数和析构函数的调用顺序？`</b><br>`创建对象过程，先调用基类的构造函数，然后依次调用类非静态成员的构造函数，最后调用自己的构造函数；销毁对象过程，先调用自己的析构函数，然后依次调用非静态成员的析构函数，最后调用基类的析构函数。`<br><b>`(33)指针和引用的区别？`</b><br>`引用和指针在汇编层面都是内存地址，引用可以看作是指针常量，只能在声明的时候初始化，相比于指针，引用的优势在于编译器帮我们检查地址是否初始化。`<br><b>`(34)符号重定义的解决方法？`</b><br>`通过 `extern`，`static`，`inline`，`const`关键字都可以解决符号重定义问题，也可以通过命名空间、前置声明、`#ifndef`和 `#pragma once`宏解决这个问题。`<br><b>`(35)四种指针类型转换的区别？`</b><br>``reinterpret_cast`用于任意指针（引用）类型之间的转换，不进行类型检查。`static_cast`用于基类和子类指针（引用）之间的转换，编译期进行类型检查。`dynamic_cast`用于基类和子类指针（引用）之间的转换，运行期进行类型检查。`const_cast`用于指针（引用）类型，用于删除限定符，不进行类型检查。`<br><b>`(36)知道什么是RVO吗？`</b><br>`RVO是一种返回值优化手段，它通过避免创建临时对象来提高代码性能。当一个函数返回一个非引用类型的变量时，编译器会尝试将该对象直接构造在调用者的栈空间中，而不是为该对象分配新的内存并在函数返回后再将其拷贝到调用者的栈空间中。`<br><b>`(37)RTTI的实现原理？`</b><br>`RTTI指的是运行时类型识别，通过虚表实现，指向类型信息的指针存放在虚表上。`<br><b>`(38)extern C的作用？`</b><br>``extern "C"` 是 C++ 提供的一个关键字，用于指示编译器将某个函数或变量的名称按照 C 语言的方式进行处理，以便与C语言进行交互。其原理上就是关闭编译器的name mangling。`<br><b>`(39)可以在运行时访问private成员吗？`</b><br>`可以，访问权限关键字只在编译期有效，运行期是没有访问权限关键字这些概念的，可以在运行时访问对象内的任何成员。`<br><b>`(40)C++的编译流程？`</b><br>`先预处理，然后编译成目标文件，接着把目标文件链接成库文件或者可执行文件。`<br><b>`(41)动态库和静态库的区别？知道动态库延迟加载优化吗？`</b><br>`链接动态库和静态库的时候，静态库会被复制到可执行程序当中，而动态库不会。相比动态库，静态库的执行效率更高，但占用磁盘空间更多，不方便更新。动态库的延迟加载指的是，在运行时按需加载动态链接库中的函数和数据，而不是在启动的时候加载库函数和数据，从而降低启动时间，在linux系统下，延迟加载是通过PLT表和GOT表配合实现的。`<br><b>`(42)智能指针是什么？几种智能指针的区别？`</b><br>`智能指针是RAII思想的一种应用，`shared_ptr`是最常用的智能指针，但是，第一，效率低，可以通过在特定场合使用 `unique_ptr`弥补这点；第二，有循环引用的问题，故引入 `weak_ptr`；第三，不能直接封装this并返回，否则会引起引用计数错误，故引入 `enable_shared_from_this`。`<br><b>`(43)四种智能指针的简单实现？`</b><br>`不考虑删除器的实现，`unique_ptr`内部封装一个指针，在构造函数内把地址传给指针，析构函数内销毁指针指向的对象；`shared_ptr`内部封装一个指针，和一个存放在堆空间的引用计数，重新实现构造、拷贝构造、赋值构造、析构函数，每次调用构造函数、赋值构造函数、拷贝构造函数的时候，通过原子操作，对引用计数加1，每次调用析构函数，通过原子操作对引用计数减1，计数为0则销毁对象；`weak_ptr`实现和 `shared_ptr`类似，不同在于它不影响引用计数；`enable_shared_from_this`通过CRTP实现。`<br><b>`(44)什么是左值和右值？它们是C++11才有的吗？`<i><i>``<b>string literal``<i><b>``<i>`是左值还是右值？`<i></b>``</i>i++``<i><b>``<i>`和`<i></i>``</b>++i``<b><b>`是左值还是右值`</b><br>`左值是可以取地址的值，右值是不可取地址的值，右值之所以不能取地址，往往是因为这些值可能在寄存器上、可能是指令的一部分、可能是栈上的匿名变量。左右值是C语言出现开始，一直都有的概念，只是没有给他们明确下定义。`string literal`是左值，`++i`是返回值是 `i`本身，是左值，`i++`会返回一个临时变量，是右值。`<br><b>`(45)什么是左右值引用？和左右值有关系吗？右值引用适合什么场景下用？`</b><br>`左值引用和右值引用在汇编层面都是地址，右值引用的出现是伴随着移动构造函数出现的，之所以引入右值引用类型的语法，是为了区分拷贝构造函数和移动构造函数，更准确地来说是为了区分深拷贝和浅拷贝。只有右值才可以赋值给右值引用，但是右值和右值引用没有严格意义上的关系，把右值赋值给右值引用往往是不合理的，反而会降低运行效率，不要把字面值赋值给右边值引用，不要以右值引用的方式返回函数返回值。右值引用仅仅适用于把将亡值传递给函数参数这类场景。`<br><b>`(46)基本类型的长度？`</b><br>`这些长度可能会因编译器、操作系统和计算机体系结构的不同而有所变化。`char`长度是1字节；`short`长度至少2字节，大多情况下2字节；`int`长度至少2字节，大多数情况下4字节；`long int`长度大于等于 `int`长度；`float`长度4字节；`double`长度8字节。所以为了移植性，一般不建议直接使用这些类型，建议使用 `int8_t`，`int16_t`，`int32_t`等类型。`<br><b>`(47)内存对齐规则？为什么要内存对齐？`</b><br>`内存对齐有两个要求，第一，C++中有对齐系数这个概念，任何类型在内存中的首地址必须是自身对齐系数的整数倍，基本类型的对齐系数等于自身大小，结构体类型的内存对齐系数等于内存占用最大的基本类型成员的大小；第二，结构体内类型，相对于结构体首地址的偏移必须等于自身对齐系数的整数倍。引入内存对齐，是为了减少CPU访问内存数据的次数，提高取数据的效率。`<br><b>`(48)通过指针访问数组，系统是如何知道指针越界的？`</b><br>`编译器编译代码期间会增加额外的代码用于检测数组是否越界。生成下标越界检查代码，C语言默认关闭；C++默认开启。`<br><b>`(49)断言是什么？断言和条件语句的优劣？`</b><br>`断言用于在代码编译或者执行期间检查特定条件是否成立，不成立则报错终止。静态断言和动态断言是两种不同类型的断言。静态断言在代码编译期间进行验证，并在发现问题时引发编译时错误；动态断言在代码运行期间进行验证，并在发现问题时引发异常或错误。C++内，动态断言通常只在调试模式下启用，而在发布模式下会被忽略。断言相比于条件语句，效率更高，但降低了程序安全性。`<br><b>`(50)继承和组合的优劣？`</b><br>`继承和组合都是代码复用的方案，继承的耦合性更高，但提供了更多复用特性，比如 `public`和 `private`复用、比如多态。`<br>`

# C++11

## 智能指针 https://zhuanlan.zhihu.com/p/436290273

### 什么是智能指针
- 对裸指针的封装，避免内存泄漏
#### unique_ptr
    - 只能通过std::move转移所有权，不能复制。
    - `unique_ptr`本身拥有的方法主要包括：

    1. `get()` 获取其保存的原生指针，尽量不要使用
    2. `bool() `判断是否拥有指针
    3. `release()` 释放所管理指针的所有权，返回原生指针。但并不销毁原生指针。
    4. `reset() `释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针
  - ```C++
    std::unique_ptr<A> a2(a1.release());//常见用法，转义拥有权
    a2.reset(new A());//释放并销毁原有对象，持有一个新对象
    a2.reset();//释放并销毁原有对象，等同于下面的写法
    a2 = nullptr;//释放并销毁原有对象
    ```
  - shared_ptr

    - 维护一个引用计数，当count为0的时候会调用delete（或者用户自定义的方法）来释放资源。
    - 方法：

      1. get()
      2. bool()
      3. reset()
      4. unique() if count==1 return true else return false;
      5. use_count()返回引用计数的大小
    - 引用计数何时增加

      - 新建shared_ptr且指向一个资源时
      - 复制构造函数创建一个新的shared_ptr时
      - 赋值运算符将一个shared_ptr赋值给另一个shared_ptr时。``int a=10; shared_ptr<int> s1=a; shared_ptr<int> s2(s1);``
    - 引用计数如何减少

      - 当一个shared_ptr对象被销毁时，比如局部变量离开作用域、类成员析构。
      - 当一个shared_ptr对象不再指向一个资源时，如使用reset方法或者赋值运算符指向另一个资源时。
    - 线程安全吗

      - 不是。多线程同时访问和修改一个shared_ptr可能会导致数据竞争和为定义行为。但是其增加、减少引用计数是线程安全的。
    - 多线程使用需要注意什么

      - 避免在多个线程中同事修改智能指针
      - 避免在多个线程中同时访问智能指针所指向的对象
      - 需要使用适当的线程同步方法来保证线程安全。
  - weak_ptr

    - 不改变引用计数本身不具备资源管理的能力，用来解决shared_ptr循环引用的问题。
    - 方法：
      1. expired()判断所指向的原生指针是否被释放，if释放->true
      2. use_count()
      3. lock()返回shared_ptr。如果原生指针没被释放，返回一个非空的shared_ptr， else返回一个空的shared_ptr
      4. reset()
  - 循环引用如何发生

    - 在**两个或多个对象**相互引用，或者一些复杂的数据结构。如图、双向链表中，存在多个引用路径的情况下，可能会存在循环引用的问题，导致资源无法被释放。